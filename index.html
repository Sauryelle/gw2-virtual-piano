<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sarya's Music Thingy</title>

    <!-- Favicon -->
    <link rel="icon" type="image/png" href="saryamusic2.png">

    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Cormorant+Garamond:wght@400;600;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --gw2-red-dark: #3a0e0e;
            --gw2-red: #6a1f1f;
            --gw2-gold: #d4af37;
            --gw2-gold-dark: #8c7355;
            --gw2-bg: #1a1818;
            --gw2-parchment: #e6d8c3;
        }

        body {
            background-color: var(--gw2-bg);
            background-image:
                radial-gradient(circle at 50% 50%, #3a2e2a 0%, #1a1818 100%),
                url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200" opacity="0.03"><filter id="n"><feTurbulence type="fractalNoise" baseFrequency="0.8" numOctaves="4"/></filter><rect width="200" height="200" filter="url(%23n)"/></svg>');
            font-family: 'Cormorant Garamond', serif;
            color: var(--gw2-parchment);
            margin: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            user-select: none;
            padding: 2rem 1rem;
            box-sizing: border-box;
            overflow-x: hidden;
        }

        .gw2-panel {
            background: linear-gradient(135deg, #2c2420, #181514);
            border: 2px solid #5a4b3c;
            box-shadow: 0 0 30px rgba(0,0,0,0.9), inset 0 0 20px rgba(0,0,0,0.8);
            position: relative;
        }

        .gw2-panel::before {
            content: '';
            position: absolute;
            top: 6px; left: 6px; right: 6px; bottom: 6px;
            border: 1px solid var(--gw2-gold-dark);
            pointer-events: none;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
        }

        .gw2-title {
            font-family: 'Cinzel', serif;
            color: var(--gw2-gold);
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9), 0 0 15px rgba(212,175,55,0.4);
            letter-spacing: 3px;
        }

        .gw2-button {
            background: linear-gradient(to bottom, var(--gw2-red), var(--gw2-red-dark));
            border: 1px solid #a83a3a;
            color: var(--gw2-parchment);
            font-family: 'Cinzel', serif;
            box-shadow: 0 3px 6px rgba(0,0,0,0.6), inset 0 1px 1px rgba(255,255,255,0.2);
            transition: all 0.15s ease;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            cursor: pointer;
        }

        .gw2-button:hover {
            background: linear-gradient(to bottom, #8a2a2a, #4a1515);
            border-color: var(--gw2-gold-dark);
            transform: translateY(-1px);
        }

        .gw2-button:active, .gw2-button.active {
            transform: translateY(2px) scale(0.98);
            background: linear-gradient(to bottom, #fff3e0, #ffb347);
            color: #5a1e00;
            border-color: var(--gw2-gold);
            box-shadow: inset -1px -1px 3px rgba(255,255,255,0.5),
                        inset 2px 4px 8px rgba(0,0,0,0.3),
                        0 0 15px #ff8c00;
        }

        .gw2-select {
            background: linear-gradient(to bottom, #2c2420, #181514);
            border: 1px solid #5a4b3c;
            color: var(--gw2-gold);
            font-family: 'Cinzel', serif;
            max-width: 280px;
            text-overflow: ellipsis;
        }

        .gw2-select option, .gw2-select optgroup {
            background: #181514;
            color: var(--gw2-parchment);
            font-family: 'Cormorant Garamond', serif;
        }

        /* --- Scribe Editor Styles --- */
        .editor-container {
            position: relative;
            width: 100%;
            height: 400px;
            max-width: 100%;
        }

        #textareaA, #textareaB {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0; left: 0;
            padding: 1.5rem;
            font-family: monospace;
            font-size: 1rem;
            line-height: 1.6rem;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow: auto;
            border-radius: 0.5rem;
            box-sizing: border-box;
            text-align: left;
        }

        #textareaA {
            color: transparent;
            caret-color: var(--gw2-gold);
            z-index: 10;
            resize: vertical;
            outline: none;
            border: 2px solid transparent;
        }

        #textareaB {
            background-color: rgba(0, 0, 0, 0.4);
            color: var(--gw2-parchment);
            border: 1px solid #5a4b3c;
            box-shadow: inset 0 5px 15px rgba(0,0,0,0.9);
            z-index: 1;
            pointer-events: none;
        }

        .highlight-red { color: #ff5555; font-weight: bold; text-shadow: 0 0 5px rgba(255,0,0,0.5); }
        .highlight-blue { color: #6fa8dc; font-weight: bold; text-shadow: 0 0 5px rgba(100,150,255,0.5); }
        .highlight-pipe { color: var(--gw2-gold); opacity: 0.6; font-weight: bold; }

        /* --- Animation Styles for Side Panels --- */
        #songbook-panel, #scribe-panel {
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            max-width: 0;
            opacity: 0;
            overflow: hidden;
            display: flex;
            pointer-events: none;
        }

        #songbook-panel {
            margin-right: 0;
            transform: translateX(-50px);
        }

        #scribe-panel {
            margin-left: 0;
            transform: translateX(50px);
        }

        #songbook-panel.is-open {
            max-width: 600px;
            opacity: 1;
            margin-right: 1.5rem;
            transform: translateX(0);
            pointer-events: auto;
        }

        #scribe-panel.is-open {
            max-width: 650px;
            opacity: 1;
            margin-left: 1.5rem;
            transform: translateX(0);
            pointer-events: auto;
        }

        @media (max-width: 1350px) {
            #songbook-panel, #scribe-panel {
                transform: translateY(50px);
                max-height: 0;
                max-width: 100%;
            }
            #songbook-panel.is-open {
                max-height: 1000px;
                margin-right: 0;
                margin-bottom: 1.5rem;
                transform: translateY(0);
            }
            #scribe-panel.is-open {
                max-height: 1200px;
                margin-left: 0;
                margin-top: 1.5rem;
                transform: translateY(0);
            }
        }

        /* --- GW2 PIANO STYLES --- */
        .piano-container {
            display: flex;
            gap: 4px;
            padding: 10px;
            background: #0a0808;
            border: 2px solid #3a2e2a;
            border-radius: 4px;
            box-shadow: inset 0 5px 15px rgba(0,0,0,0.9);
        }

        .piano-key {
            width: 70px;
            height: 240px;
            background: linear-gradient(to bottom, #d9d0c1, #a39581);
            border: 1px solid #4a3e31;
            border-radius: 2px 2px 8px 8px;
            box-shadow: inset -2px -2px 5px rgba(255,255,255,0.3),
                        inset 2px 2px 5px rgba(0,0,0,0.1),
                        3px 5px 10px rgba(0,0,0,0.7);
            position: relative;
            cursor: pointer;
            transition: transform 0.05s, box-shadow 0.05s;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
            padding-bottom: 20px;
        }

        @media (max-width: 640px) {
            .piano-key { width: 40px; height: 180px; }
            .key-note { font-size: 1rem !important; }
            .key-bind { font-size: 0.7rem !important; }
            .black-key { width: 26px; height: 110px; }
            .black-key .key-note { font-size: 0.8rem !important; }
            .black-key .key-bind { font-size: 0.55rem !important; padding: 0 2px; }
        }

        .piano-key::before {
            content: '';
            position: absolute;
            top: 0; left: 10%; right: 10%; height: 60%;
            background: linear-gradient(to bottom, rgba(255,255,255,0.2), transparent);
            border-radius: 2px;
            pointer-events: none;
        }

        .piano-key.active {
            transform: translateY(4px) scale(0.98);
            background: linear-gradient(to bottom, #fff3e0, #ffb347);
            box-shadow: inset -1px -1px 3px rgba(255,255,255,0.5),
                        inset 2px 4px 8px rgba(0,0,0,0.3),
                        0 0 20px #ff8c00;
            border-color: var(--gw2-gold);
        }

        .black-key {
            width: 44px;
            height: 140px;
            background: linear-gradient(to bottom, #2a2420, #0a0808);
            border-color: #1a1512;
            right: -2px;
            transform: translateX(50%);
        }

        .black-key::before {
            background: linear-gradient(to bottom, rgba(255,255,255,0.1), transparent);
        }

        .black-key.active {
            transform: translateX(50%) translateY(4px) scale(0.98);
            background: linear-gradient(to bottom, #5a1515, #8a2a2a);
            box-shadow: inset -1px -1px 3px rgba(255,255,255,0.2),
                        inset 2px 4px 8px rgba(0,0,0,0.6),
                        0 0 15px #ff0000;
            border-color: var(--gw2-red);
        }

        .key-note {
            font-family: 'Cinzel', serif;
            font-weight: 700;
            font-size: 1.5rem;
            color: #2c2420;
            text-shadow: 1px 1px 0px rgba(255,255,255,0.4);
        }

        .key-bind {
            font-family: 'Cormorant Garamond', serif;
            font-weight: 600;
            font-size: 1rem;
            color: #5a4b3c;
            margin-top: 5px;
        }

        .piano-key.active .key-note, .piano-key.active .key-bind {
            color: #5a1e00;
        }

        .piano-key.black-key.active .key-note, .piano-key.black-key.active .key-bind {
            color: #ffe0b2;
        }

        .black-key .key-note {
            color: #d4af37;
            text-shadow: 1px 1px 2px black;
            font-size: 1.2rem;
        }

        .black-key .key-bind {
            color: #a39581;
        }

        /* --- HEARTOPIA PIANO STYLES --- */
        #htp-view {
            background: linear-gradient(to bottom, #221c18, #110e0c);
        }

        .htp-white {
            width: 46px;
            height: 60px;
            background: #fdfdfd;
            border-radius: 12px;
            box-shadow: 0 4px 0 #b0b0b0, 0 5px 8px rgba(0,0,0,0.3);
            display: flex; flex-direction: column; align-items: center; justify-content: flex-start;
            padding-top: 6px;
            position: relative;
            cursor: pointer;
            font-family: sans-serif;
            transition: all 0.05s;
        }

        .htp-white:active, .htp-white.active {
            transform: translateY(4px);
            box-shadow: 0 0px 0 #b0b0b0, 0 2px 3px rgba(0,0,0,0.3);
            background: #e8f0fe;
        }

        .htp-white-num {
            font-weight: bold; font-size: 1.15rem; color: #222; line-height: 1;
        }

        .htp-white-sol {
            font-size: 0.55rem; color: #666; font-weight: bold; letter-spacing: 0.5px; margin-top: 2px;
        }

        .htp-bind-tag {
            position: absolute; bottom: -12px;
            background: #8e8e8e; color: white; padding: 2px 6px; border-radius: 6px;
            font-size: 0.65rem; box-shadow: 0 2px 0 #555; font-weight: bold;
            transition: all 0.05s;
        }

        .htp-white:active .htp-bind-tag, .htp-white.active .htp-bind-tag {
            box-shadow: 0 0px 0 #555; transform: translateY(2px);
        }

        .htp-black {
            width: 32px; height: 32px;
            background: #333; border-radius: 50%;
            box-shadow: 0 3px 0 #111, 0 4px 6px rgba(0,0,0,0.5);
            display: flex; align-items: center; justify-content: center;
            color: #eee; font-size: 0.75rem; font-weight: bold; font-family: sans-serif;
            position: absolute; top: -14px; right: -20px; z-index: 10; cursor: pointer;
            transition: all 0.05s;
        }

        .htp-black:active, .htp-black.active {
            transform: translateY(3px);
            box-shadow: 0 0 0 #111, 0 2px 3px rgba(0,0,0,0.5);
            background: #555;
        }

        .status-text {
            color: #a39581;
            font-style: italic;
            text-shadow: 1px 1px 2px black;
        }
    </style>
</head>
<body>

    <div class="flex flex-col xl:flex-row w-full max-w-[2200px] mx-auto items-stretch justify-center mt-12 sm:mt-0">

        <!-- ============================== -->
        <!-- LEFT PANEL: SONGBOOK           -->
        <!-- ============================== -->
        <div id="songbook-panel" class="gw2-panel flex-col w-full xl:w-[500px] 2xl:w-[600px] rounded-xl p-4">
            <h2 class="gw2-title text-2xl mb-4 text-center">Tome Viewer</h2>
            <div class="flex flex-wrap justify-center gap-3 mb-5">
                <button id="btn-load-tome-light" class="gw2-button px-3 py-1.5 rounded font-bold text-xs tracking-widest border border-[#5a4b3c] flex items-center gap-2">
                    Tome: Light
                </button>
                <button id="btn-load-tome-dark" class="gw2-button px-3 py-1.5 rounded font-bold text-xs tracking-widest border border-[#d4af37] flex items-center gap-2">
                    Tome: Dark
                </button>
            </div>
            <div class="flex justify-center gap-2 mb-2 w-full max-w-md mx-auto">
                <input type="text" id="songbook-url" class="gw2-select flex-1 px-3 py-1.5 rounded text-sm outline-none placeholder-[#8c7355]" placeholder="Paste link..." value="https://docs.google.com/document/d/1gX4ohvjG1Jr3nzWyC-mwYswzj8EsgLt9cHSNSCrTl7c/preview">
                <button id="btn-load-songbook" class="gw2-button px-4 py-1.5 rounded font-bold text-sm tracking-widest">Load</button>
            </div>
            <iframe id="songbook-frame" class="w-full flex-1 bg-[#e6d8c3] rounded border border-[#5a4b3c] min-h-[500px] xl:min-h-0" src="" title="Songbook"></iframe>
        </div>

        <!-- ============================== -->
        <!-- CENTER PANEL: PIANO            -->
        <!-- ============================== -->
        <div class="gw2-panel p-6 sm:p-10 rounded-xl flex flex-col items-center flex-1 w-full max-w-[1000px] z-20">

            <!-- Top Left: Open Songbook Button -->
            <button id="btn-toggle-songbook" class="gw2-button absolute top-4 left-4 sm:top-6 sm:left-6 px-3 py-1.5 sm:px-4 sm:py-2 rounded font-bold text-xs sm:text-sm tracking-widest text-center shadow-lg border border-[#5a4b3c] flex items-center gap-1 sm:gap-2 no-underline z-50">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 sm:h-5 sm:w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" /></svg>
                <span class="hidden sm:inline">Open Songbook</span>
                <span class="inline sm:hidden">Songs</span>
            </button>

            <!-- Top Right: Open Scribe Button -->
            <button id="btn-toggle-scribe" class="gw2-button absolute top-4 right-4 sm:top-6 sm:right-6 px-3 py-1.5 sm:px-4 sm:py-2 rounded font-bold text-xs sm:text-sm tracking-widest text-center shadow-lg border border-[#5a4b3c] flex items-center gap-1 sm:gap-2 no-underline z-50">
                <span class="hidden sm:inline">Open Scribe</span>
                <span class="inline sm:hidden">Scribe</span>
                <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 sm:h-5 sm:w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3" /></svg>
            </button>

            <!-- Header Section -->
            <div class="text-center mb-6 mt-10 sm:mt-0">
                <img src="saryamusic2.png" alt="Sarya's Music Thingy" class="mx-auto h-48 sm:h-64 mb-4 object-contain drop-shadow-[0_10px_20px_rgba(0,0,0,0.8)]" onerror="this.style.display='none'">

                <h1 class="gw2-title text-4xl sm:text-5xl mb-2">Sarya's Music Thingy</h1>
                <p class="status-text text-lg mb-6">For exclusive use of everyone.</p>

                <!-- Primary View Toggles -->
                <div class="flex justify-center w-full">
                    <button id="btn-toggle-view" class="gw2-button px-6 py-2 rounded font-bold text-sm tracking-widest text-center shadow-lg border border-[#d4af37] text-[#d4af37]">
                        Switch to Heartopia View
                    </button>
                </div>
            </div>

            <!-- Unified Audio Dashboard -->
            <div class="bg-black/30 border border-[#3a2e2a] rounded-xl p-5 w-full max-w-4xl mb-6 flex flex-col gap-5 shadow-inner">
                <div class="flex flex-wrap justify-center items-center gap-4 w-full">
                    <select id="synth-select" class="gw2-select flex-1 min-w-[200px] max-w-[280px] px-4 py-2 rounded font-bold text-sm tracking-widest cursor-pointer text-center outline-none focus:border-[#d4af37] shadow-md">
                        <optgroup label="Default Magic Instruments">
                            <option value="lute">Instrument: Lute</option>
                            <option value="brass">Instrument: Brass</option>
                            <option value="flute">Instrument: Flute</option>
                            <option value="crystal">Instrument: Crystal</option>
                        </optgroup>
                    </select>
                    <label for="sf2-upload" class="gw2-button px-4 py-2 rounded font-bold text-sm tracking-widest cursor-pointer text-center whitespace-nowrap shadow-md">
                        Load Custom SF2
                    </label>
                    <input type="file" id="sf2-upload" accept=".sf2" class="hidden">
                    <button id="btn-unload-sf2" class="gw2-button px-4 py-2 rounded font-bold text-sm tracking-widest text-center hidden whitespace-nowrap shadow-md">
                        Unload SF2
                    </button>
                </div>

                <div class="flex flex-wrap justify-center items-center gap-x-8 gap-y-4 w-full">
                    <div class="flex items-center gap-3 bg-black/40 border border-[#5a4b3c] px-3 py-1.5 rounded-lg shadow-inner" title="Master Volume">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-[#8c7355]" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" /></svg>
                        <input type="range" id="master-volume" min="0" max="1" step="0.01" value="0.8" class="w-24 accent-[#d4af37] cursor-pointer">
                    </div>

                    <div class="flex items-center gap-3 bg-black/40 border border-[#5a4b3c] px-3 py-1.5 rounded-lg shadow-inner">
                        <label class="flex items-center gap-2 cursor-pointer status-text hover:text-[#d4af37] transition-colors" title="Toggle Metronome">
                            <input type="checkbox" id="metronome-toggle" class="w-4 h-4 accent-[#6a1f1f] cursor-pointer">
                            <span class="text-sm font-bold tracking-wider">Metronome</span>
                        </label>
                        <div class="h-4 w-px bg-[#5a4b3c]"></div>
                        <input type="number" id="metronome-bpm" value="120" min="20" max="300" class="bg-transparent text-[#d4af37] w-12 text-center outline-none font-bold" title="Beats Per Minute">
                        <span class="status-text text-xs">BPM</span>
                    </div>

                    <label class="flex items-center gap-2 cursor-pointer status-text hover:text-[#d4af37] transition-colors bg-black/40 border border-[#5a4b3c] px-3 py-1.5 rounded-lg shadow-inner" title="Simulates a sustain pedal for a reverberating effect">
                        <input type="checkbox" id="sustain-toggle" class="w-4 h-4 accent-[#6a1f1f] cursor-pointer">
                        <span class="text-sm font-bold tracking-wider">Extend Notes (Sustain)</span>
                    </label>
                </div>
            </div>

            <div id="sys-message" class="text-[#d4af37] font-['Cinzel'] h-6 mb-4 opacity-0 transition-opacity duration-500 text-sm tracking-wider">
                Instrument Attuned.
            </div>

            <!-- VIEW 1: GW2 PIANO (1 Octave) -->
            <div id="gw2-view" class="flex flex-col items-center w-full">
                <div class="flex flex-col sm:flex-row justify-center w-full gap-3 items-center mb-6">
                    <button id="btn-oct-down" class="gw2-button w-full sm:w-auto px-5 py-2 rounded font-bold text-sm tracking-widest text-center shadow-md">[ Q ] Octave -</button>
                    <div class="bg-black/50 border-2 border-[#5a4b3c] px-6 py-2 rounded-lg text-center w-full sm:w-auto min-w-[160px] shadow-inner">
                        <span class="text-[#d4af37] font-['Cinzel'] font-bold text-xl drop-shadow-md" id="octave-display">Octave: Mid</span>
                    </div>
                    <button id="btn-oct-up" class="gw2-button w-full sm:w-auto px-5 py-2 rounded font-bold text-sm tracking-widest text-center shadow-md">[ E ] Octave +</button>
                </div>
                <div class="piano-container mb-6" id="piano"></div>
                <div class="flex flex-wrap justify-center items-center w-full gap-6">
                    <button id="btn-edit-binds" class="gw2-button px-6 py-2 rounded font-bold text-sm tracking-widest text-center border border-[#5a4b3c] shadow-md transition-all">Edit Binds: OFF</button>
                    <label class="flex items-center gap-2 cursor-pointer status-text hover:text-[#d4af37] transition-colors">
                        <input type="checkbox" id="octave-toggle" class="w-4 h-4 accent-[#6a1f1f] cursor-pointer" checked>
                        <span>Restrict Octaves (Low / Mid / High)</span>
                    </label>
                </div>
                <div class="mt-6 text-center status-text text-sm max-w-md" id="helper-text">
                    Use keys to play notes. Toggle <b class="text-[#d4af37]">Edit Binds</b> to change mapping. Click or touch keys to interact.
                </div>
            </div>

            <!-- VIEW 2: HEARTOPIA (3 Octaves) -->
            <div id="htp-view" class="hidden flex-col items-center w-full max-w-5xl px-4 py-8 rounded-2xl border-2 border-[#5a4b3c] shadow-inner overflow-x-auto">
                <div id="heartopia-container" class="flex flex-col gap-8 min-w-[700px] py-4 px-8"></div>
                <div class="mt-6 text-center status-text text-sm max-w-md">
                    Binds perfectly map to standard QWERTY rows to replicate the Heartopia layout exactly.
                </div>
            </div>
        </div>

        <!-- ============================== -->
        <!-- RIGHT PANEL: TOME SCRIBE       -->
        <!-- ============================== -->
        <div id="scribe-panel" class="gw2-panel flex-col w-full xl:w-[600px] 2xl:w-[650px] rounded-xl p-4">
            <h2 class="gw2-title text-3xl mb-1 text-center">Tome Scribe</h2>
            <h3 class="text-[#d4af37] font-['Cinzel'] text-sm tracking-widest font-bold mb-4 text-center">Convert arcane MIDI magic</h3>

            <div class="flex justify-center items-center w-full mb-4">
                <label for="midiFileInput" class="gw2-button px-8 py-2 rounded font-bold text-sm tracking-widest cursor-pointer text-center shadow-lg flex items-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3" /></svg>
                    Upload MIDI
                </label>
                <input type="file" id="midiFileInput" accept=".mid,.midi" class="hidden">
            </div>

            <div class="flex flex-wrap justify-center items-stretch gap-2 w-full mb-4">
                <button id="copyTabBtn" class="gw2-button px-3 py-1.5 rounded text-center shadow-lg flex flex-col items-center justify-center gap-1 border-[#5a4b3c] flex-1">
                    <div class="flex items-center gap-1 font-bold text-[0.65rem] tracking-widest whitespace-nowrap"><svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3" /></svg>Copy Tab</div>
                    <span class="text-[0.55rem] text-[#e6d8c3]/60 font-serif tracking-normal normal-case">Format by Powerina</span>
                </button>
                <button id="downloadSpreadsheetBtn" class="gw2-button px-3 py-1.5 rounded text-center shadow-lg flex flex-col items-center justify-center gap-1 border-[#5a4b3c] flex-1">
                    <div class="flex items-center gap-1 font-bold text-[0.65rem] tracking-widest whitespace-nowrap"><svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg>Spreadsheet</div>
                    <span class="text-[0.55rem] text-[#e6d8c3]/60 font-serif tracking-normal normal-case">Export by Jenpai</span>
                </button>
                <button id="exportImageBtn" class="gw2-button px-3 py-1.5 rounded text-center shadow-lg flex flex-col items-center justify-center gap-1 border-[#5a4b3c] flex-1">
                    <div class="flex items-center gap-1 font-bold text-[0.65rem] tracking-widest whitespace-nowrap"><svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" /></svg>Export Image</div>
                    <span class="text-[0.55rem] text-[#e6d8c3]/60 font-serif tracking-normal normal-case">Spell Page PNG</span>
                </button>
            </div>

            <div id="scribe-sys-message" class="text-[#d4af37] font-['Cinzel'] h-5 mb-2 opacity-0 transition-opacity duration-500 text-xs tracking-wider font-bold text-center">
                Awaiting input...
            </div>

            <div class="editor-container relative z-20 flex-1 min-h-[400px]">
                <div id="textareaB"></div>
                <div id="textareaA" contenteditable="true" spellcheck="false">Your converted tabs will appear here. You can edit them freely!</div>
            </div>
        </div>

    </div> <!-- End Flex Wrapper -->

    <!-- ============================== -->
    <!-- JAVASCRIPT MODULES             -->
    <!-- ============================== -->
    <script type="module">
        import { Midi } from "https://cdn.skypack.dev/@tonejs/midi";
        import * as XLSX from "https://cdn.sheetjs.com/xlsx-latest/package/xlsx.mjs";

        // ==========================================
        // 1. GLOBAL PIANO STATE & ELEMENTS
        // ==========================================
        let currentViewMode = 'gw2';
        let currentOctave = 4;
        let octaveMode = 'restricted';
        let audioCtx;
        let masterGainNode;
        let activeNodes = {};
        let isSustainEnabled = false;

        let metronomeInterval;
        let nextNoteTime = 0;
        let bpm = 120;
        let isMetronomeOn = false;
        let metronomeBeat = 0;

        const btnToggleView = document.getElementById('btn-toggle-view');
        const gw2View = document.getElementById('gw2-view');
        const htpView = document.getElementById('htp-view');

        const btnToggleSongbook = document.getElementById('btn-toggle-songbook');
        const songbookPanel = document.getElementById('songbook-panel');
        const songbookUrlInput = document.getElementById('songbook-url');
        const btnLoadSongbook = document.getElementById('btn-load-songbook');
        const songbookFrame = document.getElementById('songbook-frame');
        const btnLoadTomeLight = document.getElementById('btn-load-tome-light');
        const btnLoadTomeDark = document.getElementById('btn-load-tome-dark');

        const btnToggleScribe = document.getElementById('btn-toggle-scribe');
        const scribePanel = document.getElementById('scribe-panel');

        const metronomeToggle = document.getElementById('metronome-toggle');
        const bpmInput = document.getElementById('metronome-bpm');

        const btnEditBinds = document.getElementById('btn-edit-binds');
        const btnOctDown = document.getElementById('btn-oct-down');
        const btnOctUp = document.getElementById('btn-oct-up');
        const synthSelect = document.getElementById('synth-select');
        const octaveToggle = document.getElementById('octave-toggle');
        const sustainToggle = document.getElementById('sustain-toggle');

        let isSongbookOpen = false;
        let isScribeOpen = false;

        function showMessage(m) {
            const sm = document.getElementById('sys-message');
            sm.textContent = m; sm.style.opacity = 1;
            setTimeout(() => sm.style.opacity = 0, 2000);
        }

        // ==========================================
        // 2. SLIDING PANELS LOGIC
        // ==========================================
        btnToggleSongbook.addEventListener('click', () => {
            isSongbookOpen = !isSongbookOpen;
            if (isSongbookOpen) {
                songbookPanel.classList.add('is-open');
                btnToggleSongbook.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 sm:h-5 sm:w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /></svg> <span class="hidden sm:inline">Close Songbook</span><span class="inline sm:hidden">Close</span>';
                if (!songbookFrame.src) loadSongbookUrl();
            } else {
                songbookPanel.classList.remove('is-open');
                btnToggleSongbook.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 sm:h-5 sm:w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 19l-7-7m0 0l7-7m-7 7h18" /></svg> <span class="hidden sm:inline">Open Songbook</span><span class="inline sm:hidden">Songs</span>';
            }
        });

        btnToggleScribe.addEventListener('click', () => {
            isScribeOpen = !isScribeOpen;
            if (isScribeOpen) {
                scribePanel.classList.add('is-open');
                btnToggleScribe.innerHTML = '<span class="hidden sm:inline">Close Scribe</span><span class="inline sm:hidden">Close</span> <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 sm:h-5 sm:w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /></svg>';
            } else {
                scribePanel.classList.remove('is-open');
                btnToggleScribe.innerHTML = '<span class="hidden sm:inline">Open Scribe</span><span class="inline sm:hidden">Scribe</span> <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 sm:h-5 sm:w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3" /></svg>';
            }
        });

        function loadSongbookUrl() {
            let url = songbookUrlInput.value.trim();
            if (!url) return;
            if (url.includes('docs.google.com') && url.includes('/edit')) {
                url = url.replace(/\/edit.*$/, '/preview');
            }
            songbookFrame.src = url;
            showMessage("Loading Tome...");
        }

        btnLoadSongbook.addEventListener('click', loadSongbookUrl);
        songbookUrlInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') loadSongbookUrl(); });

        btnLoadTomeLight.addEventListener('click', () => {
            songbookUrlInput.value = 'https://docs.google.com/document/d/1KOYLOCvwig71yQjDXOGW9mUHWy9aoW8ziRLUBjxX_nA/preview';
            loadSongbookUrl();
        });
        btnLoadTomeDark.addEventListener('click', () => {
            songbookUrlInput.value = 'https://docs.google.com/document/d/1gX4ohvjG1Jr3nzWyC-mwYswzj8EsgLt9cHSNSCrTl7c/preview';
            loadSongbookUrl();
        });

        btnToggleView.addEventListener('click', () => {
            if (currentViewMode === 'gw2') {
                currentViewMode = 'heartopia';
                gw2View.classList.add('hidden');
                htpView.classList.remove('hidden');
                htpView.classList.add('flex');
                btnToggleView.textContent = "Switch to Guild Wars 2 View";
                showMessage("Heartopia Resonance engaged.");
            } else {
                currentViewMode = 'gw2';
                htpView.classList.add('hidden');
                htpView.classList.remove('flex');
                gw2View.classList.remove('hidden');
                btnToggleView.textContent = "Switch to Heartopia View";
                showMessage("Tyrian Resonance engaged.");
            }
        });

        // ==========================================
        // 3. PIANO BINDINGS & AUDIO LOGIC
        // ==========================================
        const notes = [
            { name: 'C', offset: 0, isBlack: false }, { name: 'C#', offset: 1, isBlack: true },
            { name: 'D', offset: 2, isBlack: false }, { name: 'D#', offset: 3, isBlack: true },
            { name: 'E', offset: 4, isBlack: false }, { name: 'F', offset: 5, isBlack: false },
            { name: 'F#', offset: 6, isBlack: true }, { name: 'G', offset: 7, isBlack: false },
            { name: 'G#', offset: 8, isBlack: true }, { name: 'A', offset: 9, isBlack: false },
            { name: 'A#', offset: 10, isBlack: true }, { name: 'B', offset: 11, isBlack: false },
            { name: 'C', offset: 12, isBlack: false }
        ];

        let bindings = {
            notes: ['Digit1', 'F1', 'Digit2', 'F2', 'Digit3', 'Digit4', 'F4', 'Digit5', 'F5', 'Digit6', 'F6', 'Digit7', 'Digit8'],
            octaveDown: 'KeyQ', octaveUp: 'KeyE'
        };

        try { const savedBinds = localStorage.getItem('tyrianPianoBinds'); if (savedBinds) bindings = JSON.parse(savedBinds); } catch (e) {}
        function saveBinds() { try { localStorage.setItem('tyrianPianoBinds', JSON.stringify(bindings)); } catch (e) {} }

        let activeRebind = null;
        let isRemappingMode = false;

        function formatKey(code) {
            if (code.startsWith('Key')) return code.slice(3);
            if (code.startsWith('Digit')) return code.slice(5);
            return code;
        }

        function getFormattedBindString(code, octave) {
            let keyStr = code === '?' ? '?' : formatKey(code);
            if (octave < 4) return `[ ${keyStr} ]`;
            if (octave > 4) return `( ${keyStr} )`;
            return keyStr;
        }

        function startRebind(e, type, index, targetEl) {
            e.stopPropagation(); e.preventDefault();
            if (activeRebind) cancelRebind();
            let originalText = targetEl.innerHTML;
            targetEl.innerHTML = `<span class="text-[#ff8c00] animate-pulse">?</span>`;
            activeRebind = { type, index, el: targetEl, originalText };
            showMessage("Press any key to bind...");
        }

        function cancelRebind() {
            if (!activeRebind) return;
            activeRebind.el.innerHTML = activeRebind.originalText;
            activeRebind = null;
        }

        const htpLayout = [
            { octave: 5, dot: 'top', keys: [ { offset: 0, solfege: 'DO', bindLabel: 'Q', code: 'KeyQ', num: 1, type: 'white' }, { offset: 1, bindLabel: '2', code: 'Digit2', type: 'black' }, { offset: 2, solfege: 'RE', bindLabel: 'W', code: 'KeyW', num: 2, type: 'white' }, { offset: 3, bindLabel: '3', code: 'Digit3', type: 'black' }, { offset: 4, solfege: 'MI', bindLabel: 'E', code: 'KeyE', num: 3, type: 'white' }, { offset: 5, solfege: 'FA', bindLabel: 'R', code: 'KeyR', num: 4, type: 'white', gap: true }, { offset: 6, bindLabel: '5', code: 'Digit5', type: 'black' }, { offset: 7, solfege: 'SOL', bindLabel: 'T', code: 'KeyT', num: 5, type: 'white' }, { offset: 8, bindLabel: '6', code: 'Digit6', type: 'black' }, { offset: 9, solfege: 'LA', bindLabel: 'Y', code: 'KeyY', num: 6, type: 'white' }, { offset: 10, bindLabel: '7', code: 'Digit7', type: 'black' }, { offset: 11, solfege: 'SI', bindLabel: 'U', code: 'KeyU', num: 7, type: 'white' }, { offset: 12, solfege: 'DO', bindLabel: 'I', code: 'KeyI', num: 1, type: 'white' } ]},
            { octave: 4, dot: 'none', keys: [ { offset: 0, solfege: 'DO', bindLabel: 'Z', code: 'KeyZ', num: 1, type: 'white' }, { offset: 1, bindLabel: 'S', code: 'KeyS', type: 'black' }, { offset: 2, solfege: 'RE', bindLabel: 'X', code: 'KeyX', num: 2, type: 'white' }, { offset: 3, bindLabel: 'D', code: 'KeyD', type: 'black' }, { offset: 4, solfege: 'MI', bindLabel: 'C', code: 'KeyC', num: 3, type: 'white' }, { offset: 5, solfege: 'FA', bindLabel: 'V', code: 'KeyV', num: 4, type: 'white', gap: true }, { offset: 6, bindLabel: 'G', code: 'KeyG', type: 'black' }, { offset: 7, solfege: 'SOL', bindLabel: 'B', code: 'KeyB', num: 5, type: 'white' }, { offset: 8, bindLabel: 'H', code: 'KeyH', type: 'black' }, { offset: 9, solfege: 'LA', bindLabel: 'N', code: 'KeyN', num: 6, type: 'white' }, { offset: 10, bindLabel: 'J', code: 'KeyJ', type: 'black' }, { offset: 11, solfege: 'SI', bindLabel: 'M', code: 'KeyM', num: 7, type: 'white' } ]},
            { octave: 3, dot: 'bottom', keys: [ { offset: 0, solfege: 'DO', bindLabel: ',', code: 'Comma', num: 1, type: 'white' }, { offset: 1, bindLabel: 'L', code: 'KeyL', type: 'black' }, { offset: 2, solfege: 'RE', bindLabel: '.', code: 'Period', num: 2, type: 'white' }, { offset: 3, bindLabel: ';', code: 'Semicolon', type: 'black' }, { offset: 4, solfege: 'MI', bindLabel: '/', code: 'Slash', num: 3, type: 'white' }, { offset: 5, solfege: 'FA', bindLabel: 'O', code: 'KeyO', num: 4, type: 'white', gap: true }, { offset: 6, bindLabel: '0', code: 'Digit0', type: 'black' }, { offset: 7, solfege: 'SOL', bindLabel: 'P', code: 'KeyP', num: 5, type: 'white' }, { offset: 8, bindLabel: '-', code: 'Minus', type: 'black' }, { offset: 9, solfege: 'LA', bindLabel: '[', code: 'BracketLeft', num: 6, type: 'white' }, { offset: 10, bindLabel: '=', code: 'Equal', type: 'black' }, { offset: 11, solfege: 'SI', bindLabel: ']', code: 'BracketRight', num: 7, type: 'white' } ]}
        ];
        const heartopiaBindsMap = {};

        // Restore fully featured SF2 Storage Cache
        let sf2Data = { buffer: null, smplOffset: 0, smplSize: 0, presets: [], bufferCache: {} };

        // Essential for proper native SF2 volume decay
        function timecentsToSecs(tc) {
            if (tc <= -11950) return 0.001;
            return Math.pow(2, tc / 1200);
        }

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                masterGainNode = audioCtx.createGain();
                const volSlider = document.getElementById('master-volume');
                masterGainNode.gain.value = volSlider.value;
                masterGainNode.connect(audioCtx.destination);
                volSlider.addEventListener('input', (e) => masterGainNode.gain.setValueAtTime(e.target.value, audioCtx.currentTime));
            }
            if (audioCtx.state === 'suspended') audioCtx.resume();
        }

        // Restored Native SF2 Audio Buffer Decoder
        function loadSf2Buffer(sampleInfo) {
            initAudio();
            try {
                const numSamples = sampleInfo.end - sampleInfo.start;
                if (numSamples <= 0 || numSamples > 50000000) return null;

                let sr = sampleInfo.sampleRate || 44100;
                if (sr < 8000) sr = 8000;
                if (sr > 96000) sr = 96000;

                const buffer = audioCtx.createBuffer(1, numSamples, sr);
                const channelData = buffer.getChannelData(0);
                const dv = new DataView(sf2Data.buffer);

                let byteOffset = sf2Data.smplOffset + (sampleInfo.start * 2);

                for (let i = 0; i < numSamples; i++) {
                    channelData[i] = dv.getInt16(byteOffset, true) / 32768.0;
                    byteOffset += 2;
                }
                return buffer;
            } catch(e) {
                return null;
            }
        }

        function playNote(offset, octave, elementId) {
            initAudio();
            if (activeNodes[elementId]) return;

            const midiNote = 12 * (octave + 1) + offset;
            const freq = 440 * Math.pow(2, (midiNote - 69) / 12);
            const instrumentMode = synthSelect.value;

            // Restored full SF2 vs Synth logic check
            if (instrumentMode.startsWith('sf2_')) {
                // SF2 Synth Processing
                const sfIndex = parseInt(instrumentMode.split('_')[1]);
                const preset = sf2Data.presets[sfIndex];

                const velocity = 100;
                let matchedZones = preset.zones.filter(z =>
                    midiNote >= z.keyRange.low && midiNote <= z.keyRange.high &&
                    velocity >= z.velRange.low && velocity <= z.velRange.high
                );

                if (matchedZones.length === 0) matchedZones = preset.zones.filter(z => midiNote >= z.keyRange.low && midiNote <= z.keyRange.high);
                if (matchedZones.length === 0 && preset.zones.length > 0) matchedZones = [preset.zones[0]];

                const sources = [];
                const gainNodes = [];

                matchedZones.forEach(zone => {
                    let cacheKey = zone.sample.name + "_" + zone.sample.start;
                    if (!sf2Data.bufferCache[cacheKey]) {
                        sf2Data.bufferCache[cacheKey] = loadSf2Buffer(zone.sample);
                    }

                    const buffer = sf2Data.bufferCache[cacheKey];
                    if (buffer) {
                        const gainNode = audioCtx.createGain();

                        let rootPitch = zone.rootKey !== undefined ? zone.rootKey : zone.sample.originalPitch;
                        if (rootPitch === 255 || rootPitch === 0) rootPitch = 60;

                        let centsOffset = zone.tuneCents + (zone.sample.pitchCorrection || 0);
                        const playbackRate = Math.pow(2, (midiNote - rootPitch + (centsOffset / 100)) / 12);

                        const source = audioCtx.createBufferSource();
                        source.buffer = buffer;
                        source.playbackRate.value = playbackRate;

                        if ((zone.sampleModes & 1) === 1 || (zone.sampleModes & 3) === 3) {
                            source.loop = true;
                            source.loopStart = Math.max(0, (zone.sample.startLoop - zone.sample.start) / zone.sample.sampleRate);
                            source.loopEnd = Math.max(0, (zone.sample.endLoop - zone.sample.start) / zone.sample.sampleRate);
                        }

                        let dly = timecentsToSecs(zone.volEnv.delay);
                        let atk = timecentsToSecs(zone.volEnv.attack);
                        let hld = timecentsToSecs(zone.volEnv.hold);
                        let dec = timecentsToSecs(zone.volEnv.decay);

                        let susGain = 1.0;
                        if (zone.volEnv.sustain > 0) {
                            let attenuationDB = zone.volEnv.sustain / 10;
                            susGain = Math.max(0.001, Math.pow(10, -attenuationDB / 20));
                        }

                        let baseGain = 1.0 / Math.max(1, matchedZones.length);
                        let now = audioCtx.currentTime;

                        gainNode.gain.setValueAtTime(0, now);
                        if (dly > 0.002) gainNode.gain.setValueAtTime(0, now + dly);
                        gainNode.gain.linearRampToValueAtTime(baseGain, now + dly + atk);
                        if (hld > 0.002) gainNode.gain.setValueAtTime(baseGain, now + dly + atk + hld);
                        gainNode.gain.exponentialRampToValueAtTime(Math.max(0.001, baseGain * susGain), now + dly + atk + hld + dec);

                        source.connect(gainNode);
                        gainNode.connect(masterGainNode);
                        source.start(now + dly);

                        sources.push(source);
                        gainNodes.push(gainNode);
                    }
                });

                if (sources.length > 0) {
                    activeNodes[elementId] = { sources, gainNodes, zones: matchedZones, mode: 'sf2' };
                }

            } else {
                // Procedural Multi-Synth Restore
                const gainNode = audioCtx.createGain();
                const osc1 = audioCtx.createOscillator();
                const osc2 = audioCtx.createOscillator();
                const filterNode = audioCtx.createBiquadFilter();

                if (instrumentMode === 'lute') {
                    osc1.type = 'sawtooth'; osc2.type = 'triangle';
                    osc1.frequency.value = freq; osc2.frequency.value = freq * 1.002;
                    filterNode.type = 'lowpass';
                    filterNode.frequency.setValueAtTime(4000, audioCtx.currentTime);
                    filterNode.frequency.exponentialRampToValueAtTime(300, audioCtx.currentTime + 0.5);
                    gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.8, audioCtx.currentTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.1, audioCtx.currentTime + 1.2);
                } else if (instrumentMode === 'brass') {
                    osc1.type = 'square'; osc2.type = 'sine';
                    osc1.frequency.value = freq; osc2.frequency.value = freq * 0.998;
                    filterNode.type = 'lowpass';
                    filterNode.frequency.setValueAtTime(1000, audioCtx.currentTime);
                    filterNode.frequency.linearRampToValueAtTime(2500, audioCtx.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.6, audioCtx.currentTime + 0.1);
                    gainNode.gain.setTargetAtTime(0.4, audioCtx.currentTime + 0.1, 0.3);
                } else if (instrumentMode === 'flute') {
                    osc1.type = 'sine'; osc2.type = 'sine';
                    osc1.frequency.value = freq; osc2.frequency.value = freq * 1.005;
                    filterNode.type = 'lowpass'; filterNode.frequency.setValueAtTime(2000, audioCtx.currentTime);
                    gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.5, audioCtx.currentTime + 0.15);
                    gainNode.gain.setTargetAtTime(0.4, audioCtx.currentTime + 0.15, 0.2);
                } else if (instrumentMode === 'crystal') {
                    osc1.type = 'triangle'; osc2.type = 'sine';
                    osc1.frequency.value = freq; osc2.frequency.value = freq * 2;
                    filterNode.type = 'bandpass'; filterNode.frequency.setValueAtTime(freq * 2, audioCtx.currentTime);
                    filterNode.Q.value = 5;
                    gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.5, audioCtx.currentTime + 0.02);
                    gainNode.gain.exponentialRampToValueAtTime(0.05, audioCtx.currentTime + 2.0);
                }

                osc1.connect(filterNode); osc2.connect(filterNode);
                filterNode.connect(gainNode); gainNode.connect(masterGainNode);
                osc1.start(); osc2.start();

                activeNodes[elementId] = { osc1, osc2, gainNode, mode: instrumentMode };
            }

            const keyEl = document.getElementById(elementId);
            if (keyEl) keyEl.classList.add('active');
        }

        function stopNote(elementId) {
            if (!activeNodes[elementId]) return;

            const node = activeNodes[elementId];
            const mode = node.mode;

            if (mode === 'sf2') {
                const { sources, gainNodes, zones } = node;
                let now = audioCtx.currentTime;

                for (let i = 0; i < sources.length; i++) {
                    let gainNode = gainNodes[i];
                    let source = sources[i];
                    let zone = zones[i];

                    let rel = timecentsToSecs(zone.volEnv.release);
                    rel = Math.max(rel, isSustainEnabled ? 5.0 : 1.5);

                    gainNode.gain.cancelScheduledValues(now);
                    gainNode.gain.setValueAtTime(gainNode.gain.value, now);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, now + rel);
                    source.stop(now + rel + 0.1);
                }
            } else {
                const { osc1, osc2, gainNode } = node;
                let baseRelease = (mode === 'crystal') ? 2.5 : (mode === 'brass' ? 1.5 : 1.5);
                let releaseTime = isSustainEnabled ? baseRelease * 3 : baseRelease;

                gainNode.gain.cancelScheduledValues(audioCtx.currentTime);
                gainNode.gain.setValueAtTime(gainNode.gain.value, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + releaseTime);
                osc1.stop(audioCtx.currentTime + releaseTime);
                osc2.stop(audioCtx.currentTime + releaseTime);
            }

            delete activeNodes[elementId];

            const keyEl = document.getElementById(elementId);
            if (keyEl) keyEl.classList.remove('active');
        }

        const pianoContainer = document.getElementById('piano');
        const htpContainer = document.getElementById('heartopia-container');
        let currentWrapper = null;
        notes.forEach((note, index) => {
            const keyEl = document.createElement('div');
            const elementId = `gw2-key-${index}`;
            keyEl.id = elementId;
            keyEl.className = `piano-key ${note.isBlack ? 'black-key absolute top-0 z-10' : 'relative'}`;
            keyEl.innerHTML = `<div class="key-note">${note.name}</div><div class="key-bind" data-index="${index}">${getFormattedBindString(bindings.notes[index], currentOctave)}</div>`;
            const interact = (e) => { if(isRemappingMode) startRebind(e, 'note', index, keyEl.querySelector('.key-bind')); else playNote(note.offset, currentOctave, elementId); };
            keyEl.addEventListener('mousedown', interact);
            keyEl.addEventListener('touchstart', (e) => { e.preventDefault(); interact(e); });
            keyEl.addEventListener('mouseup', () => stopNote(elementId));
            keyEl.addEventListener('mouseleave', () => stopNote(elementId));
            keyEl.addEventListener('touchend', (e) => { e.preventDefault(); stopNote(elementId); });
            if (!note.isBlack) {
                currentWrapper = document.createElement('div');
                currentWrapper.className = 'relative flex-none';
                currentWrapper.appendChild(keyEl);
                pianoContainer.appendChild(currentWrapper);
            } else if (currentWrapper) currentWrapper.appendChild(keyEl);
        });

        htpLayout.forEach(row => {
            const rowEl = document.createElement('div');
            rowEl.className = 'flex justify-center gap-2 relative';
            let lastWhite = null;
            row.keys.forEach(key => {
                const elementId = `htp-key-${row.octave}-${key.offset}`;
                heartopiaBindsMap[key.code] = { octave: row.octave, offset: key.offset, elementId };
                if (key.type === 'white') {
                    const wrap = document.createElement('div');
                    wrap.className = `relative flex-none ${key.gap ? 'ml-8' : ''}`;
                    wrap.innerHTML = `<div id="${elementId}" class="htp-white"><div class="htp-white-num">${key.num}</div><div class="htp-white-sol">${key.solfege}</div><div class="htp-bind-tag">${key.bindLabel}</div></div>`;
                    const el = wrap.querySelector('.htp-white');
                    el.addEventListener('mousedown', () => playNote(key.offset, row.octave, elementId));
                    el.addEventListener('mouseup', () => stopNote(elementId));
                    rowEl.appendChild(wrap);
                    lastWhite = wrap;
                } else {
                    const black = document.createElement('div');
                    black.id = elementId; black.className = 'htp-black'; black.textContent = key.bindLabel;
                    black.addEventListener('mousedown', () => playNote(key.offset, row.octave, elementId));
                    black.addEventListener('mouseup', () => stopNote(elementId));
                    if (lastWhite) lastWhite.appendChild(black);
                }
            });
            htpContainer.appendChild(rowEl);
        });

        window.addEventListener('keydown', (e) => {
            // Prevent browser default actions for F-keys (like F5 refresh or F1 help)
            if (/^F\d+$/.test(e.code)) {
                e.preventDefault();
            }

            if (e.target.tagName === 'INPUT') return;
            if (e.repeat) return;

            if (currentViewMode === 'gw2') {
                if (activeRebind) {
                    bindings.notes[activeRebind.index] = e.code;
                    activeRebind.el.innerHTML = getFormattedBindString(e.code, currentOctave);
                    saveBinds(); showMessage("Bound!"); activeRebind = null; return;
                }
                if (e.code === bindings.octaveDown) updateOctave(-1);
                else if (e.code === bindings.octaveUp) updateOctave(1);
                else {
                    let idx = bindings.notes.indexOf(e.code);

                    // Restore Numpad Fallback Logic
                    let fallbackIdx = -1;
                    const defaultDigitMap = {
                        'Numpad1': 0, 'Numpad2': 2, 'Numpad3': 4, 'Numpad4': 5,
                        'Numpad5': 7, 'Numpad6': 9, 'Numpad7': 11, 'Numpad8': 12
                    };
                    if (defaultDigitMap[e.code] !== undefined) {
                        let mappedIndex = defaultDigitMap[e.code];
                        let digitCode = 'Digit' + e.code.slice(6);
                        if (bindings.notes[mappedIndex] === digitCode) fallbackIdx = mappedIndex;
                    }

                    if (idx !== -1) playNote(notes[idx].offset, currentOctave, `gw2-key-${idx}`);
                    else if (fallbackIdx !== -1) playNote(notes[fallbackIdx].offset, currentOctave, `gw2-key-${fallbackIdx}`);
                }
            } else {
                let bind = heartopiaBindsMap[e.code];
                if (bind) playNote(bind.offset, bind.octave, bind.elementId);
            }
        });

        window.addEventListener('keyup', (e) => {
            // Prevent browser default actions for F-keys on release as well
            if (/^F\d+$/.test(e.code)) {
                e.preventDefault();
            }

            if (e.target.tagName === 'INPUT') return;
            if (currentViewMode === 'gw2') {
                let idx = bindings.notes.indexOf(e.code);

                // Restore Numpad Fallback Logic for Keyup
                let fallbackIdx = -1;
                const defaultDigitMap = {
                    'Numpad1': 0, 'Numpad2': 2, 'Numpad3': 4, 'Numpad4': 5,
                    'Numpad5': 7, 'Numpad6': 9, 'Numpad7': 11, 'Numpad8': 12
                };
                if (defaultDigitMap[e.code] !== undefined) {
                    let mappedIndex = defaultDigitMap[e.code];
                    let digitCode = 'Digit' + e.code.slice(6);
                    if (bindings.notes[mappedIndex] === digitCode) fallbackIdx = mappedIndex;
                }

                if (idx !== -1) stopNote(`gw2-key-${idx}`);
                else if (fallbackIdx !== -1) stopNote(`gw2-key-${fallbackIdx}`);
            } else {
                let bind = heartopiaBindsMap[e.code];
                if (bind) stopNote(bind.elementId);
            }
        });

        function updateOctave(d) {
            currentOctave += d;
            if (octaveMode === 'restricted') {
                if (currentOctave < 3) currentOctave = 3;
                if (currentOctave > 5) currentOctave = 5;
            }
            document.getElementById('octave-display').textContent = `Octave: ${currentOctave === 4 ? 'Mid' : (currentOctave === 3 ? 'Low' : 'High')}`;
            document.querySelectorAll('#gw2-view .key-bind').forEach(el => {
                let i = el.dataset.index;
                el.textContent = getFormattedBindString(bindings.notes[i], currentOctave);
            });
        }

        btnEditBinds.addEventListener('click', () => {
            isRemappingMode = !isRemappingMode;
            btnEditBinds.textContent = isRemappingMode ? 'Edit Binds: ON' : 'Edit Binds: OFF';
            btnEditBinds.classList.toggle('text-[#d4af37]');
        });

        octaveToggle.addEventListener('change', (e) => { octaveMode = e.target.checked ? 'restricted' : 'full'; updateOctave(0); });
        sustainToggle.addEventListener('change', (e) => isSustainEnabled = e.target.checked);

        // ==========================================
        // 3.5 RESTORED METRONOME & NATIVE SF2 PARSER
        // ==========================================
        const sf2Upload = document.getElementById('sf2-upload');
        const btnUnloadSf2 = document.getElementById('btn-unload-sf2');

        synthSelect.addEventListener('change', (e) => {
            showMessage(`Instrument attuned to: ${e.target.options[e.target.selectedIndex].text}`);
        });

        function playClick(time) {
            const osc = audioCtx.createOscillator();
            const envelope = audioCtx.createGain();

            osc.type = 'triangle';
            // Higher pitched accent on the first beat of 4
            osc.frequency.value = (metronomeBeat % 4 === 0) ? 1000 : 800;

            // Proper standard Web Audio node ramp init
            envelope.gain.setValueAtTime(1, time);
            envelope.gain.exponentialRampToValueAtTime(0.001, time + 0.1);

            osc.connect(envelope);
            envelope.connect(masterGainNode);

            osc.start(time);
            osc.stop(time + 0.1);

            metronomeBeat++;
        }

        function scheduleMetronome() {
            while (nextNoteTime < audioCtx.currentTime + 0.1) {
                playClick(nextNoteTime);
                nextNoteTime += 60.0 / bpm;
            }
        }

        metronomeToggle.addEventListener('change', (e) => {
            isMetronomeOn = e.target.checked;
            if (isMetronomeOn) {
                initAudio();
                metronomeBeat = 0;
                nextNoteTime = audioCtx.currentTime + 0.05;
                metronomeInterval = setInterval(scheduleMetronome, 25);
                showMessage(`Metronome started at ${bpm} BPM.`);
            } else {
                clearInterval(metronomeInterval);
                showMessage("Metronome stopped.");
            }
        });

        bpmInput.addEventListener('change', (e) => {
            let val = parseInt(e.target.value);
            if (isNaN(val) || val < 20) val = 20;
            if (val > 300) val = 300;
            bpmInput.value = val;
            bpm = val;
            if (isMetronomeOn) showMessage(`BPM attuned to ${bpm}.`);
        });

        btnUnloadSf2.addEventListener('click', () => {
            const optgroup = document.getElementById('sf2-optgroup');
            if (optgroup) optgroup.remove();

            synthSelect.value = 'lute';
            sf2Data = { buffer: null, smplOffset: 0, smplSize: 0, presets: [], bufferCache: {} };
            sf2Upload.value = '';

            btnUnloadSf2.classList.add('hidden');
            showMessage("Soundfont un-attuned. Memory cleared.");
        });

        sf2Upload.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            showMessage(`Attuning ${file.name}... parsing arcane structures.`);
            const reader = new FileReader();

            reader.onload = function(evt) {
                try {
                    const arrayBuffer = evt.target.result;
                    const dv = new DataView(arrayBuffer);
                    let offset = 0;

                    sf2Data = { buffer: arrayBuffer, smplOffset: 0, smplSize: 0, presets: [], bufferCache: {} };

                    function readStrAt(off, len) {
                        let s = '';
                        for(let i=0; i<len; i++) {
                            let c = dv.getUint8(off + i);
                            if (c === 0) break;
                            if (c >= 32 && c <= 126) s += String.fromCharCode(c);
                        }
                        return s.trim();
                    }

                    function readStr(len) {
                        let s = readStrAt(offset, len);
                        offset += len;
                        return s;
                    }

                    let pdtaChunks = {};

                    while (offset < arrayBuffer.byteLength - 8) {
                        let chunkId = readStr(4);
                        let chunkSize = dv.getUint32(offset, true); offset += 4;

                        if (chunkId === 'RIFF' || chunkId === 'LIST') {
                            readStr(4);
                            continue;
                        }

                        let nextOffset = offset + chunkSize;
                        if (chunkSize % 2 !== 0) nextOffset++;

                        if (chunkId === 'smpl') {
                            sf2Data.smplOffset = offset;
                            sf2Data.smplSize = chunkSize;
                        } else if (['phdr', 'pbag', 'pgen', 'inst', 'ibag', 'igen', 'shdr'].includes(chunkId)) {
                            pdtaChunks[chunkId] = { offset, size: chunkSize };
                        }
                        offset = nextOffset;
                    }

                    if (pdtaChunks.phdr && pdtaChunks.shdr && sf2Data.smplSize > 0) {
                        let shdr = [], igen = [], ibag = [], inst = [], pgen = [], pbag = [], phdr = [];

                        let o = pdtaChunks.shdr.offset, end = o + pdtaChunks.shdr.size;
                        while(o < end) {
                            shdr.push({
                                name: readStrAt(o, 20), start: dv.getUint32(o+20, true), end: dv.getUint32(o+24, true),
                                startLoop: dv.getUint32(o+28, true), endLoop: dv.getUint32(o+32, true),
                                sampleRate: dv.getUint32(o+36, true), originalPitch: dv.getUint8(o+40),
                                pitchCorrection: dv.getInt8(o+41), sampleType: dv.getUint16(o+44, true)
                            }); o += 46;
                        }

                        o = pdtaChunks.igen.offset; end = o + pdtaChunks.igen.size;
                        while(o < end) { igen.push({ oper: dv.getUint16(o, true), amount: dv.getUint16(o+2, true), amountInt: dv.getInt16(o+2, true) }); o += 4; }

                        o = pdtaChunks.ibag.offset; end = o + pdtaChunks.ibag.size;
                        while(o < end) { ibag.push({ genNdx: dv.getUint16(o, true) }); o += 4; }

                        o = pdtaChunks.inst.offset; end = o + pdtaChunks.inst.size;
                        while(o < end) { inst.push({ name: readStrAt(o, 20), ibagNdx: dv.getUint16(o+20, true) }); o += 22; }

                        o = pdtaChunks.pgen.offset; end = o + pdtaChunks.pgen.size;
                        while(o < end) { pgen.push({ oper: dv.getUint16(o, true), amount: dv.getUint16(o+2, true) }); o += 4; }

                        o = pdtaChunks.pbag.offset; end = o + pdtaChunks.pbag.size;
                        while(o < end) { pbag.push({ genNdx: dv.getUint16(o, true) }); o += 4; }

                        o = pdtaChunks.phdr.offset; end = o + pdtaChunks.phdr.size;
                        while(o < end) {
                            phdr.push({ name: readStrAt(o, 20), preset: dv.getUint16(o+20, true), bank: dv.getUint16(o+22, true), pbagNdx: dv.getUint16(o+24, true) });
                            o += 38;
                        }

                        for (let i = 0; i < phdr.length - 1; i++) {
                            let preset = phdr[i];
                            if (preset.name === 'EOP') continue;
                            let presetZones = [];

                            for (let j = preset.pbagNdx; j < phdr[i+1].pbagNdx; j++) {
                                let pGenEnd = pbag[j+1] ? pbag[j+1].genNdx : pgen.length;
                                let instId = -1;
                                for (let k = pbag[j].genNdx; k < pGenEnd; k++) if (pgen[k].oper === 41) instId = pgen[k].amount;

                                if (instId >= 0 && instId < inst.length - 1) {
                                    let globalInstZone = {
                                        tuneCents: 0, velRange: { low: 0, high: 127 }, sampleModes: 0,
                                        volEnv: { delay: -12000, attack: -12000, hold: -12000, decay: -12000, sustain: 0, release: -12000 }
                                    };

                                    for (let z = inst[instId].ibagNdx; z < inst[instId+1].ibagNdx; z++) {
                                        let iGenEnd = ibag[z+1] ? ibag[z+1].genNdx : igen.length;

                                        let zoneData = {
                                            keyRange: { low: 0, high: 127 }, velRange: { ...globalInstZone.velRange },
                                            tuneCents: globalInstZone.tuneCents, sampleModes: globalInstZone.sampleModes,
                                            volEnv: { ...globalInstZone.volEnv }
                                        };
                                        let sampleId = -1;

                                        for (let g = ibag[z].genNdx; g < iGenEnd; g++) {
                                            let gen = igen[g];
                                            if (gen.oper === 43) zoneData.keyRange = { low: gen.amount & 0xFF, high: gen.amount >> 8 };
                                            else if (gen.oper === 44) zoneData.velRange = { low: gen.amount & 0xFF, high: gen.amount >> 8 };
                                            else if (gen.oper === 53) sampleId = gen.amount;
                                            else if (gen.oper === 58) zoneData.rootKey = gen.amount & 0xFF;
                                            else if (gen.oper === 51) zoneData.tuneCents += gen.amountInt * 100;
                                            else if (gen.oper === 52) zoneData.tuneCents += gen.amountInt;
                                            else if (gen.oper === 54) zoneData.sampleModes = gen.amount;
                                            else if (gen.oper === 33) zoneData.volEnv.delay = gen.amountInt;
                                            else if (gen.oper === 34) zoneData.volEnv.attack = gen.amountInt;
                                            else if (gen.oper === 35) zoneData.volEnv.hold = gen.amountInt;
                                            else if (gen.oper === 36) zoneData.volEnv.decay = gen.amountInt;
                                            else if (gen.oper === 37) zoneData.volEnv.sustain = gen.amountInt;
                                            else if (gen.oper === 38) zoneData.volEnv.release = gen.amountInt;
                                        }

                                        if (sampleId === -1 && z === inst[instId].ibagNdx) {
                                            globalInstZone = zoneData;
                                        } else if (sampleId >= 0 && sampleId < shdr.length) {
                                            zoneData.sample = shdr[sampleId];
                                            presetZones.push(zoneData);
                                        }
                                    }
                                }
                            }
                            if (presetZones.length > 0) sf2Data.presets.push({ name: preset.name, bank: preset.bank, presetId: preset.preset, zones: presetZones });
                        }
                    }

                    if (sf2Data.presets.length > 0) {
                        let optgroup = document.getElementById('sf2-optgroup');
                        if (!optgroup) {
                            optgroup = document.createElement('optgroup');
                            optgroup.id = 'sf2-optgroup';
                            optgroup.label = `SF2: ${file.name}`;
                            synthSelect.appendChild(optgroup);
                        }
                        optgroup.innerHTML = '';

                        sf2Data.presets.forEach((preset, index) => {
                            let opt = document.createElement('option');
                            opt.value = 'sf2_' + index;
                            let bnk = preset.bank === 128 ? 'Perc' : preset.bank;
                            opt.textContent = `[Bank ${bnk}] ${preset.name}`;
                            optgroup.appendChild(opt);
                        });

                        synthSelect.value = 'sf2_0';
                        btnUnloadSf2.classList.remove('hidden');
                        showMessage(`Success! Reconstructed ${sf2Data.presets.length} Presets.`);
                    } else {
                        showMessage(`Could not read valid instrument presets.`);
                    }

                } catch (e) {
                    showMessage(`Error parsing Soundfont file.`);
                }
            };
            reader.readAsArrayBuffer(file);
        });

        // ==========================================
        // 4. TOME SCRIBE LOGIC (Original Formats)
        // ==========================================
        let originalFileName = "converted";

        function showScribeMessage(msg) {
            const sm = document.getElementById('scribe-sys-message');
            sm.textContent = msg; sm.style.opacity = 1;
            setTimeout(() => sm.style.opacity = 0, 4000);
        }

        const settings = { beatNote: 'time', octaveOffset: 0, steps: 0, barSkip: 0, barsPerRow: 4 };

        const timeSigUnits = (timesignature, ppq) => {
            let barUnit = ppq; let ticksPerBar = ppq * 4;
            switch (timesignature[1]) {
                case 1: barUnit = ppq * 4; break; case 2: barUnit = ppq * 2; break;
                case 4: barUnit = ppq; break; case 8: barUnit = ppq / 2; break;
                case 16: barUnit = ppq / 4; break; case 32: barUnit = ppq / 8; break; default: break;
            }
            ticksPerBar = barUnit * timesignature[0];
            if (settings.beatNote !== 'time') {
                switch (settings.beatNote) {
                    case '2': barUnit = ppq * 2; break; case '4': barUnit = ppq; break;
                    case '8': barUnit = ppq / 2; break; case '16': barUnit = ppq / 4; break;
                    case '32': barUnit = ppq / 8; break; case '64': barUnit = ppq / 16; break;
                    case '128': barUnit = ppq / 32; break; case '256': barUnit = ppq / 64; break; default: break;
                }
            }
            return { unit: barUnit, perBar: ticksPerBar };
        }

        const nextTimeSig = (timesignatures, index, currTick) => (timesignatures[index].ticks <= currTick);
        const nextTempo = (tempos, index, currTick) => (tempos[index].ticks <= currTick);

        const getOctaveBrackets = (octave, min, max) => {
            let middleOctave = min + Math.floor((max - min) / 2);
            middleOctave += settings.octaveOffset;
            if (octave > middleOctave + 1) return { start: '<', end: '>', high: true };
            if (octave < middleOctave - 1) return { start: '{', end: '}', low: true };
            if (octave === middleOctave - 1) return { start: '[', end: ']' };
            if (octave === middleOctave + 1) return { start: '(', end: ')' };
            return { start: '', end: '' };
        }

        const ticksToPause = (ticks, quarter, isNote) => {
            let sixteenth = quarter / 4;
            const notes = [
                { ticks: (sixteenth * 7), pause: '.  -' }, { ticks: (sixteenth * 6), pause: '  -' },
                { ticks: (sixteenth * 5), pause: '.  ' }, { ticks: (sixteenth * 4), pause: '  ' },
                { ticks: (sixteenth * 3.5), pause: '\u00B7. ' }, { ticks: (sixteenth * 3), pause: '\u00B7 ', notNote: '\u00B7' },
                { ticks: (sixteenth * 2.5), pause: '. ' }, { ticks: (sixteenth * 2), pause: ' ' },
                { ticks: (sixteenth * 1.75), pause: '\u00B7.' }, { ticks: (sixteenth * 1.5), pause: '\u00B7' },
                { ticks: (sixteenth * 1.25), pause: '.' }, { ticks: (sixteenth), pause: '', notNote: '\u00B7' },
                { ticks: (sixteenth * 0.5), pause: '' }, { ticks: (sixteenth * 0.25), pause: '' },
                { ticks: (sixteenth * 0.125), pause: '' }
            ];

            const closest = notes.reduce((resp, note) => {
                if (ticks > notes[0].ticks) return false;
                if (resp === false) resp = note;
                let respVal = Math.abs(resp.ticks - ticks);
                let noteVal = Math.abs(note.ticks - ticks);
                if (respVal === 0) return resp;
                if (noteVal <= respVal) return note;
                return resp;
            }, false);
            let ret = closest.pause;
            if (closest.notNote && !isNote) ret = closest.notNote;
            return { ticks: closest.ticks, ret: ret };
        }

        const addPauseTicks = (gw2, ticks, unit, note, first) => {
            if (first && !note) {
                gw2 += (ticks / unit >= 1) ? ' ' : ''
                while ((ticks / unit) >= 1) { gw2 += '\u2501 '; ticks -= unit; }
                switch (ticks) { case unit / 1.5: gw2 += '-. '; ticks = 0; break; case unit / 2: gw2 += '- '; ticks = 0; break; case unit / 4: gw2 += '. '; ticks = 0; break; default: break; }
            }
            if (ticks <= 0) return gw2;

            let addOn = '';
            while ((ticks / unit) > 1.5) { addOn += '\u2501 '; ticks -= unit; }
            let pause = ticksToPause(ticks, unit, note);

            if (pause) {
                let append = false;
                append = pause.ret[pause.ret.length - 1] !== ' ' ? pause.ret + '' + addOn : pause.ret + addOn + ''
                append = append.replace('  -\u2501', ' \u2501 \u2501');
                gw2 += append;
            } else gw2 += '' + addOn + '';

            return gw2;
        }

        const transposeNote = (note) => {
            const notes = { 1: 1, '1#': 2, 2: 3, '2#': 4, 3: 5, 4: 6, '4#': 7, 5: 8, '5#': 9, 6: 10, '6#': 11, 7: 12 }
            let nVal = notes[note] + settings.steps; let octaveDiff = 0;
            while (nVal > 12) { nVal -= 12; octaveDiff++; }
            while (nVal < 1) { nVal += 12; octaveDiff--; }
            let key = Object.keys(notes).find(key => notes[key] === nVal)
            return { note: key, octaveDiff: octaveDiff }
        }

        const parseFile = async (arrayBuffer) => {
            let midi = new Midi(arrayBuffer);
            const ppq = midi.header.ppq; const quarter = ppq;
            const multipleSignatures = midi.header.timeSignatures.length > 1;
            let gw2 = ''; const tempos = midi.header.tempos;
            const keyToNum = { C: 1, D: 2, E: 3, F: 4, G: 5, A: 6, B: 7 };

            midi.tracks = midi.tracks.reduce((sum, val) => { if (val.notes && val.notes.length > 0) sum.push(val); return sum; }, []);

            const tracks = midi.tracks.map(track => {
                let currTimeSig = midi.header.timeSignatures[0].timeSignature;
                let timeSigIndex = 1; let tempoIndex = 1;
                let units = timeSigUnits(currTimeSig, ppq);
                let ticksPerBar = units.perBar; let barUnit = units.unit;

                let currTick = 0;
                let bars = [{ notes: [], tick: currTick, ticks: ticksPerBar, unit: barUnit, timeSignatureChange: [currTimeSig] }];
                const notes = track.notes;
                let minOctave = 1337; let maxOctave = -1337;

                notes.forEach(n => { n.isSharp = n.pitch.indexOf('#') !== -1; n.pitch = n.pitch.substr(0, 1); })
                notes.sort((a, b) => {
                    if (a.ticks - b.ticks !== 0) return a.ticks - b.ticks;
                    if (a.octave - b.octave !== 0) return a.octave - b.octave;
                    return keyToNum[a.pitch] - keyToNum[b.pitch];
                });

                let currentOctave = -1; let prevTick = 0;

                notes.forEach((note, index) => {
                    if (index === 0) { currentOctave = note.octave; prevTick = note.ticks; }
                    currentOctave = note.octave; prevTick = note.ticks;
                    if (tempos[tempoIndex] && nextTempo(tempos, tempoIndex, prevTick)) {
                        note.tempo = Math.floor(tempos[tempoIndex].bpm);
                        tempoIndex++;
                        while (tempos[tempoIndex] && nextTempo(tempos, tempoIndex, prevTick)) {
                            note.tempoChange = Math.floor(tempos[tempoIndex].bpm); tempoIndex++;
                        }
                    }
                    while (currTick <= note.ticks) {
                        currTick += ticksPerBar;
                        if (multipleSignatures && midi.header.timeSignatures[timeSigIndex] && nextTimeSig(midi.header.timeSignatures, timeSigIndex, currTick)) {
                            units = timeSigUnits(midi.header.timeSignatures[timeSigIndex].timeSignature, ppq);
                            currTimeSig = midi.header.timeSignatures[timeSigIndex]; timeSigIndex++;
                            ticksPerBar = units.perBar; barUnit = units.unit;
                            bars.push({ notes: [], tick: currTick, ticks: ticksPerBar, unit: barUnit, timeSignature: currTimeSig });
                        } else bars.push({ notes: [], tick: currTick, ticks: ticksPerBar, unit: barUnit });
                    }
                    const barIndex = bars.findIndex(x => note.ticks >= x.tick && note.ticks < (x.tick + x.ticks));
                    bars[barIndex].notes.push(note);
                    if (note.octave > maxOctave) maxOctave = note.octave;
                    if (note.octave < minOctave) minOctave = note.octave;
                })

                currentOctave = -1; let previousOctave = -1;
                let brackets = { start: '', end: '' }; let count = 1;

                bars = bars.map((bar, bIndex) => {
                    gw2 = '|';
                    if (bar.notes.length > 0) {
                        let pauseTicks = bar.notes[0].ticks - bar.tick;
                        if (pauseTicks > 0) gw2 = addPauseTicks(gw2, pauseTicks, bar.unit, false, true);
                        prevTick = 0;
                        bar.notes.forEach((note, index) => {
                            if (note.tempoChange && note.tempoChange !== '') gw2 += note.tempoChange;

                            let key = keyToNum[note.pitch] + (note.isSharp ? '#' : '');
                            let nTransposed = transposeNote(key);
                            note.octave = note.octave + nTransposed.octaveDiff;
                            key = nTransposed.note;
                            if (!isNaN(key)) key = parseInt(key);

                            const nextNote = bar.notes[index + 1];
                            let startOffset = 0;
                            if (currentOctave === -1) currentOctave = note.octave;

                            if (index === 0) {
                                prevTick = note.ticks;
                                if (key === 1 && currentOctave < note.octave) { key = 8; startOffset = -1; }
                                let noteOctave = note.octave + startOffset;
                                brackets = getOctaveBrackets(noteOctave, minOctave, maxOctave);
                                if (key === 1 && brackets.high) { key = 8; startOffset = -1; brackets = getOctaveBrackets(noteOctave, minOctave, maxOctave); }
                                noteOctave = note.octave + startOffset;
                                currentOctave = noteOctave;
                                gw2 += brackets.start; gw2 += key;
                            } else {
                                let starterBracket = false;
                                let checkBrack = getOctaveBrackets(note.octave, minOctave, maxOctave);
                                if (previousOctave !== note.octave && key !== 1) {
                                    gw2 += brackets.end; currentOctave = note.octave;
                                    brackets = getOctaveBrackets(currentOctave, minOctave, maxOctave); starterBracket = true;
                                } else if (previousOctave !== note.octave) {
                                    if (previousOctave < note.octave && (!nextNote || (nextNote && nextNote.ticks !== note.ticks))) {
                                        key = 8;
                                        if (previousOctave !== note.octave - 1) { gw2 += brackets.end; starterBracket = true; }
                                        currentOctave = note.octave - 1;
                                        brackets = getOctaveBrackets(currentOctave, minOctave, maxOctave);
                                    } else {
                                        gw2 += brackets.end; currentOctave = note.octave;
                                        brackets = getOctaveBrackets(currentOctave, minOctave, maxOctave); starterBracket = true;
                                    }
                                } else if ((brackets.high || checkBrack.high) && key === 1) {
                                    gw2 += brackets.end; key = 8; currentOctave = note.octave - 1;
                                    brackets = getOctaveBrackets(currentOctave, minOctave, maxOctave);
                                } else if (key === 1 && nextNote && nextNote.octave < note.octave && nextNote.ticks !== note.ticks && (nextNote.ticks - note.ticks) < quarter) {
                                    gw2 += brackets.end; key = 8; currentOctave = note.octave - 1;
                                    brackets = getOctaveBrackets(currentOctave, minOctave, maxOctave);
                                }

                                if (previousOctave !== currentOctave) starterBracket = true;
                                pauseTicks = note.ticks - prevTick;
                                gw2 = (pauseTicks > 0 ? addPauseTicks(gw2, pauseTicks, bar.unit, true) : gw2 + '/');
                                gw2 += (starterBracket ? brackets.start : ''); gw2 += key;
                                prevTick = note.ticks;
                            }

                            if (index === bar.notes.length - 1) {
                                gw2 += brackets.end;
                                pauseTicks = (bar.tick + bar.ticks) - note.ticks;
                                if (pauseTicks > 0) gw2 = addPauseTicks(gw2, pauseTicks, bar.unit, false);
                            }
                            previousOctave = currentOctave;
                        });
                    } else { gw2 = addPauseTicks(gw2, bar.ticks, bar.unit, false, true); }

                    let trueIndex = bIndex - settings.barSkip;
                    if (trueIndex > -1) {
                        if (count === settings.barsPerRow) { gw2 += '|\n'; count = 0; }
                        count++;
                    } else if (trueIndex === -1) gw2 += '|';
                    bar.text = gw2;
                    return bar;
                });
                return { name: track.name || "Instrument", bars: bars };
            })
            return tracks;
        }

        const midiInput = document.getElementById("midiFileInput");
        const textareaA = document.getElementById("textareaA");
        const textareaB = document.getElementById("textareaB");

        function escapeHtml(unsafe) {
            return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
        }

        function applyHighlighting(text) {
            let safeText = escapeHtml(text);
            safeText = safeText.replace(/\((.*?)\)/g, `<span class="highlight-red">($1)</span>`);
            safeText = safeText.replace(/\[(.*?)\]/g, `<span class="highlight-blue">[$1]</span>`);
            safeText = safeText.replace(/\|/g, `<span class="highlight-pipe">|</span>`);
            return safeText;
        }

        function syncText() { textareaB.innerHTML = applyHighlighting(textareaA.innerText); }
        const syncScroll = (source, target) => { target.scrollTop = source.scrollTop; target.scrollLeft = source.scrollLeft; };

        textareaA.addEventListener('scroll', () => syncScroll(textareaA, textareaB));
        textareaB.addEventListener('scroll', () => syncScroll(textareaB, textareaA));

        const resizeObserver = new ResizeObserver(() => {
            setTimeout(() => { if (textareaA && textareaB) { textareaB.style.width = `${textareaA.offsetWidth}px`; textareaB.style.height = `${textareaA.offsetHeight}px`; } }, 0);
        });
        resizeObserver.observe(textareaA);
        textareaA.addEventListener("input", syncText);

        midiInput.addEventListener("change", async () => {
            const file = midiInput.files[0];
            if (!file) return;
            showScribeMessage(`Scribing ${file.name}... Please wait.`);
            originalFileName = file.name;

            try {
                const arrayBuffer = await file.arrayBuffer();
                const tracks = await parseFile(arrayBuffer);
                let tabNotes = file.name + "\n\n";

                tracks.forEach(track => {
                    tabNotes += "--- " + track.name + " ---\n";
                    let trackStr = "";
                    track.bars.forEach(bar => { trackStr += bar.text; });
                    trackStr = trackStr.replace(/\|/g, "|");
                    tabNotes += trackStr + "\n\n";
                });

                textareaA.innerText = '';
                textareaA.innerText = tabNotes;
                textareaA.dispatchEvent(new Event('input', { bubbles: true }));
                showScribeMessage(`Scribe complete. Notation generated successfully.`);
            } catch (e) { showScribeMessage(`Error parsing MIDI file.`); }
            midiFileInput.value = '';
        });

        document.getElementById("copyTabBtn").addEventListener("click", () => {
            const content = textareaA.innerText.trim();
            if (!content) return showScribeMessage("Nothing to copy!");
            const textArea = document.createElement("textarea");
            textArea.value = content; document.body.appendChild(textArea); textArea.select();
            try { document.execCommand('copy'); showScribeMessage("Tabs copied to clipboard!"); }
            catch (ex) { showScribeMessage("Failed to copy tabs."); }
            document.body.removeChild(textArea);
        });

        document.getElementById("exportImageBtn").addEventListener("click", () => {
            const text = textareaA.innerText.trim();
            if (!text) return showScribeMessage("There is nothing to export.");
            showScribeMessage("Inking Spell Page...");

            let canvas = document.createElement('canvas'); let ctx = canvas.getContext('2d');
            let lines = text.split('\n'); ctx.font = "bold 16px monospace";
            let maxLineObj = lines.reduce((a, b) => a.length > b.length ? a : b, "");
            let textWidth = ctx.measureText(maxLineObj).width;

            canvas.width = Math.max(800, textWidth + 100); canvas.height = lines.length * 24 + 160;
            let grad = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            grad.addColorStop(0, '#2c2420'); grad.addColorStop(1, '#181514');
            ctx.fillStyle = grad; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#8c7355'; ctx.lineWidth = 4; ctx.strokeRect(10, 10, canvas.width - 20, canvas.height - 20);

            ctx.fillStyle = '#d4af37'; ctx.font = "bold 26px serif"; ctx.textAlign = "center";
            ctx.fillText("Tome of Melodies: Transcribed Spell Page", canvas.width / 2, 50);

            ctx.textAlign = "left"; ctx.font = "bold 16px monospace"; ctx.fillStyle = '#e6d8c3';
            let y = 100;
            for (let line of lines) {
                if (line.startsWith('---')) { ctx.fillStyle = '#d4af37'; ctx.fillText(line, 50, y); ctx.fillStyle = '#e6d8c3'; }
                else { ctx.fillText(line, 50, y); }
                y += 24;
            }

            let link = document.createElement('a');
            link.download = `${originalFileName.replace(/\.(mid|midi)$/i, '')}_SpellPage.png`;
            link.href = canvas.toDataURL('image/png'); link.click();
        });

        // 5. ISOLATED SPREADSHEET EXPORTER FIX
        document.getElementById("downloadSpreadsheetBtn").addEventListener("click", () => {
            const content = textareaA.innerText.trim();
            if (!content) return showScribeMessage("There is nothing to download.");
            showScribeMessage("Generating Spreadsheet...");

            const lines = content.split("\n");
            const sheets = {}; const sheetCounts = {};
            let currentSheetKey = null;
            let baseFileName = "converted";

            for (const rawLine of lines) {
                const line = rawLine.trim();

                if (!baseFileName || baseFileName === "converted") {
                    const match = line.match(/(.+?)\.(mid|midi)$/i);
                    if (match) baseFileName = match[1].trim();
                }

                // Detect exactly the track headers we output
                if (line.startsWith("--- ") && line.endsWith(" ---")) {
                    const baseName = line.replace(/-/g, '').trim().slice(0, 31);
                    const count = (sheetCounts[baseName] || 0) + 1;
                    sheetCounts[baseName] = count;
                    const sheetName = count === 1 ? baseName : `${baseName} ${count}`;
                    currentSheetKey = sheetName;
                    sheets[currentSheetKey] = [[baseName]];
                }
                // Convert each line into spreadsheet cells
                else if (currentSheetKey && line !== "") {
                    // Powerina Format: Pipes delineate measures
                    if (line.includes('|')) {
                        const measures = line.split('|').map(m => m.trim()).filter(m => m !== '');
                        for (let measureStr of measures) {
                            let tokens = measureStr.split(/\s+/).filter(t => t !== '');
                            if (tokens.length === 0) continue;

                            let cells = [];
                            let numCells = 4;
                            let baseSize = Math.floor(tokens.length / numCells);
                            let remainder = tokens.length % numCells;

                            let startIndex = 0;
                            // Mathematically distribute the tokens into exactly 4 cells
                            for (let i = 0; i < numCells; i++) {
                                let size = baseSize + (i < remainder ? 1 : 0);
                                if (size === 0) {
                                    cells.push(''); // Pad empty cells if fewer than 4 items
                                } else {
                                    let cellTokens = tokens.slice(startIndex, startIndex + size);
                                    cells.push(cellTokens.join(' ')); // Group items like [6] 3/6/8 into one cell
                                    startIndex += size;
                                }
                            }
                            sheets[currentSheetKey].push(cells);
                        }
                    }
                    // Legacy Jenpai Format: Separated by multiple spaces or tabs
                    else if (rawLine.includes('  ') || rawLine.includes('\t')) {
                        let items = rawLine.split(/ {2,}|\t/g).map(cell => cell.trim()).filter(c => c !== '');
                        // Force 4 cells per row, moving downwards
                        for (let i = 0; i < items.length; i += 4) {
                            let row = items.slice(i, i + 4);
                            while (row.length < 4) row.push(''); // Pad to 4 columns
                            sheets[currentSheetKey].push(row);
                        }
                    }
                    // Standard text fallback
                    else {
                        sheets[currentSheetKey].push([line]);
                    }
                }
            }

            const wb = XLSX.utils.book_new();
            for (const [sheetName, data] of Object.entries(sheets)) {
                const ws = XLSX.utils.aoa_to_sheet(data);
                XLSX.utils.book_append_sheet(wb, ws, sheetName);
            }
            XLSX.writeFile(wb, `${baseFileName}.xlsx`);
            showScribeMessage("Spreadsheet successfully exported!");
        });
    </script>
</body>
</html>
